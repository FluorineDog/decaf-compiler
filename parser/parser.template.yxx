/* Infix notation calculator.  */
%code top{
  // #include <math.h>
  // #include <stdio.h>
  #include <iostream>
  using std::cout;
  using std::cin;
}
%code requires{
  #include "common.h"
}
%code{
  int yylex (void);
  void yyerror (char const *);
  node_ptr_t root;
}


%define api.value.type {node_ptr_t}
/* Bison declarations.  */
// %union {
//   double value_double;
//   Fuck value_int;
// }

%token END_OF_FILE 0
%token T_real
%token T_integer
%token REAL
%token ID
@#token_list#@

%% /* The grammar follows.  */
input: 
  block{
    root = $1;
  }
;

block:
  %empty     {$$ = make_shared<Block>();}
| block line {
    $$ = $1;
    auto block = dynamic_cast<Block*>($$.get());
    if($1 != nullptr){
      block->stmts.emplace_back($2);
    }
  }
;

line:
  T_semicolon {$$ = nullptr;}
| exp T_semicolon  { 
    // printf ("\t$%.10g\n", $1); 
  }
;
exp:
  num                   { $$ = $1;     }
| exp T_plus num        { $$ = mkBinaryExpr($1, T_plus, $3);}
;
num:
  T_real { $$=yylval; }
| T_integer  { $$=yylval; }
;

%%

int main(){
  yyparse();
  PrintVisitor v;
  root->accept(v);
}